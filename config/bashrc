# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# play nice with others
umask 002

# specify the One True Editor
export EDITOR=/usr/bin/vim

# various paths
export CPATH=~/include:~/local/include:$CPATH
case $HOSTNAME in
    hugin) 
        export PATH=~/local/jdk-7/bin:~/local/glassfish3/bin:$PATH:~/local/android-sdk-linux/tools:~/local/android-sdk-linux/platform-tools
        export JAVA_HOME=~/local/jdk-7
        export ANDROID_HOME=~/local/android-sdk-linux
        ;;
    hapax)
        export JAVA_HOME=~/local/jdk-6
        export ANDROID_HOME=~/local/android-sdk-linux
        export PATH=~/local/android-sdk-linux/tools:~/local/jdk-6/bin:~/local/glassfish3/bin:~/local/apache-jmeter/bin:$PATH
        export PERL_LOCAL_LIB_ROOT="/home/nathan/perl5";
        export PERL_MB_OPT="--install_base /home/nathan/perl5";
        export PERL_MM_OPT="INSTALL_BASE=/home/nathan/perl5";
        export PERL5LIB="/home/nathan/perl5/lib/perl5/x86_64-linux-gnu-thread-multi:/home/nathan/perl5/lib/perl5";
        export PATH="/home/nathan/perl5/bin:$PATH";
        ;;
    wintermute) 
        export JAVA_HOME=~/local/jdk-6
        export PATH=~/local/android-sdk-linux/tools:~/local/jdk-6/bin:$PATH
        #export PATH=~/hs/bin:~/local/arm-elf/bin:$PATH 
        ;;
esac

# ensure my personal tmp exists
[ -d ~/tmp/ ] || mkdir ~/tmp

[ -d ~/.cabal/ ] && export PATH=~/.cabal/bin:$PATH
[ -d ~/scripts/shell ] && export PATH=~/scripts/shell:$PATH
# maybe a function pathadd() to encapsulate the above pattern?
# pathcons, pathsnoc
export PATH=~/bin:~/dotfiles/bin:$PATH:/var/lib/gems/1.8/bin
export PYTHONPATH=~/lib/python

# the rest of this only matters if this shell is interactive
[ -z "$PS1" ] && return

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
[ -f /etc/bash_completion ] && . /etc/bash_completion

# don't put duplicate lines in the history. 
# ... and ignore same sucessive entries.
export HISTCONTROL=ignoreboth
export HISTIGNORE="[   ]*:&:bg:fg:exit"

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# When changing directory small typos can be ignored by bash
# for example, cd /vr/lgo/apaache would find /var/log/apache
shopt -s cdspell

# don't overwrite .bash_history
shopt -s histappend
# sync history between bashes http://briancarper.net/blog/248/
#export PROMPT_COMMAND="history -a; history -n"

shopt -s no_empty_cmd_completion
shopt -s shift_verbose
#shopt -s checkhash

# disable annoying console beep
[ -x setterm ] && setterm -blength 0

# make less more friendly for non-text input files, see lesspipe(1)
# sets $LESSOPEN variable
#[ -x /usr/bin/lesspipe ] && eval "$(lesspipe)"
[ -x $HOME/bin/lesspipe.sh ] && eval "$($HOME/bin/lesspipe.sh)"
export LESS_ADVANCED_PREPROCESSOR=yes

# ansi styling
# now following the advice of http://mywiki.wooledge.org/BashFAQ/037
# with some help from http://wiki.bash-hackers.org/scripting/terminalcodes
RESET=$(tput sgr0)
BOLD=$(tput bold)
NOBOLD=$(tput rmso)

BLACK=$(tput setaf 0)
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELLOW=$(tput setaf 3)
BLUE=$(tput setaf 4)
MAGENTA=$(tput setaf 5)
CYAN=$(tput setaf 6)
WHITE=$(tput setaf 7)
PLAIN=$(tput setaf 9)

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "$debian_chroot" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

hostcolor=$GREEN
curdircolor=${BOLD}${BLUE}

case "$HOSTNAME" in 
    hugin)          hostcolor=${BLUE} ;;
    wintermute)     hostcolor=$BOLD$WHITE;;
    dev1)           hostcolor=$BOLD$CYAN ;;
    lildeb)         hostcolor=${BOLD}${YELLOW} ;;
    munin)          hostcolor=$RED ;;
    nathan-imac)    hostcolor=$BOLD$WHITE ;;
    nathan-xp)      ;;
    octavius)       ;;
    xathan)         hostcolor=$MAGENTA ;;
    hapax)          hostcolor=${BOLD}${WHITE} ;;
    gir)            ;;
    prod-app01.bits.illinoisstate.edu)   hostcolor=$BOLD$CYAN ;;
    prod-app02.bits.illinoisstate.edu)   hostcolor=$BOLD$CYAN ;;
esac

case "$USER" in
    nathan|nstien|Nathan|"Nathan Stien") 
        usercolor=$GREEN
        terminator=âˆ«
        ;;
    root|Administrator) 
        usercolor=$BOLD$RED;
        terminator='#'
        ;;
    *)
        usercolor=$BOLD$YELLOW
        terminator='\$'
        ;;
esac

# idea: re-eval prompt colors on every prompt
# do something interesting with pathcolor based on $PWD
# maybe alter shade for outside of $HOME tree?
# different color for network shares?
# ! detect symlinks in the path and highlight them individually cyan? !
    # split dir into components
        # recursive method
            # $ basename $(dirname $(dirname /foo/bar/baz/quux))
            # bar
    # pick highlight based on is_symlink
    # implementation choices
        # figure out how to do this in bash
        # embed a small python script in bash
            # then we require python for this feature
                # [ -x $(which python) ] && do_python_thing
            # performance: have to launch python every shell
# any other highlighting of path nodes?  
    # private dirs? (og-r)


# enable fancy git prompt if possible
if [ "$(type -t __git_ps1)" == "function" ]; then
    gitsection="\[$RED\]\$(__git_ps1 '(%s)')"
else
    gitsection=""
fi


# \[ and \] tell bash that the enclosed characters are non-printing,
# so it can calculate screen usage; see http://mywiki.wooledge.org/BashFAQ/053
prefix=${debian_chroot:+($debian_chroot)}
PS1="$prefix\[$usercolor\]\u\[$RESET$PLAIN$YELLOW\]@\[$hostcolor\]\h\[$PLAIN\]:\[$curdircolor\]\w${gitsection}\[$PLAIN$RESET\]$terminator "

# extra git info
GIT_PS1_SHOWDIRTYSTATE=1 #... untagged(*) and staged(+) changes
GIT_PS1_SHOWSTASHSTATE=1 #... if something is stashed($)
GIT_PS1_SHOWUNTRACKEDFILES=1 #... untracked files(%)

# non-color fallback for unknown terminals
# TODO: find more reliable method of detecting color capability.
case "$TERM" in
    xterm-color|xterm-256color|xterm|cygwin|linux|screen) ;;
    *) PS1='${prefix}\u@\h:\w\$ ' ;;
esac

# too many aliases to keep here, now we just source another file
if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

# keychain ssh key management (non-interactive)
# TODO: just detect the files?  maybe keychain can auto-add.
if [ -x "$(which keychain 2> /dev/null)" ]; then  
    # i really need to clean up my key filenames...
    keychain --quiet --ignore-missing \
        ~/.ssh/id_rsa                 \
        ~/.ssh/id_dsa                 \
        ~/.ssh/github.id_dsa          \
        ~/.ssh/nathan_github.dsa      \
        ~/.ssh/id_dsa.xenkibbutz-new  \
        ~/.ssh/nathan-gitolite.dsa

        # ~/.ssh/id_dsa.xenkibbutz      

    . ~/.keychain/${HOSTNAME}-sh
fi

# automatically invoke screen if we're not in a session already
if [ -x `which screen` ] && [ "$TERM" != "screen" ] && [ "$DISPLAY" != ":0" ] && [ "$DISPLAY" != ":0.0" ]; then
    # -xRR will attach without detaching other sessions
    screen -xRR
fi


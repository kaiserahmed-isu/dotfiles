""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Nathan's vimrc.  Like it or lump it.
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" TODO: harvest more good ideas from these
" http://stackoverflow.com/questions/164847/what-is-in-your-vimrc
" http://nvie.com/posts/how-i-boosted-my-vim/
" http://stevelosh.com/blog/2010/09/coming-home-to-vim/

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" General behavioral settings

" use pathogen for sanity
call pathogen#runtime_append_all_bundles()
filetype plugin indent on

set nocompatible        " vi sucks, long live vim
set history=1000        " longer command history
set undolevels=1000     " so much undo
set ruler               " show the cursor position all the time
set showcmd             " display incomplete commands
set incsearch           " do incremental searching
set hlsearch            " highlight search matches
set smartcase           " search case-insensitive if all lower
set visualbell t_vb=    " i hate beeping!
set noerrorbells        " still hate beeping!
set hidden              " hide rather than delete buffers
set autochdir           " change to the directory of the active buffer
set showmatch           " show matching parens
set backspace=indent,eol,start  " backspace everything in insert mode
set title               " change terminal title
set scrolloff=4         " keep 4 lines off the edges of the screen when scrolling

set splitbelow          " new windows below old ones
set shiftround          " round to nearest multiple of shiftwidth

set statusline=%F%m%r%h%w\ %{&ff}\ %{&ft}\ %P\ (%l,%v)\ %{fugitive#statusline()}
set laststatus=2        " always show status line

" put swap files in my personal tmp dir
" the double slash means that vim should use full paths,
" subbing % for /.  ~/tmp/%home%nathan%example
set directory=~/tmp//
set backupdir=~/tmp//   " keep *~ out of .

set mouse=              " disable mouse usage in terminal

set wildmenu            " show a listing of wildcard completions
set wildmode=longest,full " make completion more bash-like
set wildignore=*.swp,*.bak,*.pyc,*.class,*.o

set clipboard=unnamed   " use gui clipboard if possible



set listchars=tab:▸\ ,trail:·,extends:#,nbsp:·
set nolist                      " don't show invisible characters by default,
                                " but it is enabled for some file types (see later)

" python, haskell, and softtabstop have made me a spaces man
set autoindent
set copyindent          " preserve structure of previous indent
set tabstop=4
set shiftwidth=4
set softtabstop=4
set expandtab           " write spaces instead of \t
set smarttab
set foldmethod=syntax
set foldlevel=99
set matchpairs+=<:>

set pastetoggle=<f12>   " quick toggle for paste mode

if &t_Co > 2 || has("gui_running")
    syntax on          " enable syntax highlighting
endif

if has("gui_running")
    " only looks good in the GUI
    set cursorline          " highlight the current line
endif



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Configuration variables

" TODO: check platform, existence of binaries, etc.
let g:haddock_browser = "/usr/bin/konqueror"
let g:haddock_indexfiledir = "~/.vim/"
" huzzah for doxygen
let g:load_doxygen_syntax=1

" don't spam me for not having ruby
let g:LustyExplorerSuppressRubyWarning = 1

" For Win32 GUI: remove 't' flag from 'guioptions': no tearoff menu entries
let &guioptions = substitute(&guioptions, "t", "", "g")
" also just ditch the toolbar, since it adds nothing to a keyboard-driven app
let &guioptions = substitute(&guioptions, "T", "", "g")



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Auto Commands
if has("autocmd")
    " Put these in an autocmd group, so that we can delete them easily.
    augroup vimrcEx
        au!

        " For all text files set 'textwidth' to 78 characters.
        autocmd FileType text setlocal textwidth=78

        " When editing a file, always jump to the last known cursor position.
        " Don't do it when the position is invalid or when inside an event handler
        " (happens when dropping a file on gvim).
        autocmd BufReadPost *
                    \ if line("'\"") > 0 && line("'\"") <= line("$") |
                    \   exe "normal! g`\"" |
                    \ endif
    augroup end

    augroup invisible_chars "{{{
        au!

        " Show invisible characters in all of these files
        autocmd filetype vim,c,cpp,perl,haskell,make,python,rst,ruby setlocal list
        autocmd filetype javascript,css setlocal list
    augroup end "}}}

    "http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/vim.html
    au BufEnter *.hs compiler ghc

    " support multi-ad template files
    au BufNewFile,BufReadPost *.thtml setl filetype=html


    " i don't know why the bundled ftdetect isn't covering this...
    autocmd BufNewFile,BufRead *.coffee set filetype=coffee

endif " has("autocmd")


" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
        \ | wincmd p | diffthis




""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"" Keystrokes

" it's the default, but let's be clear
let mapleader="\\"

" nice tab navigation  (these need work...)
nmap <s-left> :tabprevious<cr>
nmap <s-right> :tabnext<cr>

" f4 and shift-f4 to go forward and backards in errors/greps
nmap <f4> :cn<cr>
nmap <s-f4> :cp<cr>

" <c-]> jumps to the tag under the cursor;
" <c-\> is my analogue for using :ptag
nmap <c-\> :exe "silent! ptag " . expand("<cword>")<cr>

" Quick yanking to the end of the line
nmap Y y$

" Yank/paste to the OS clipboard with ,y and ,p
nmap <leader>y "+y
nmap <leader>Y "+yy
nmap <leader>p "+p
nmap <leader>P "+P

" select recent pasted text (for indenting etc.)
nnoremap <leader>v V`]

" run Ack fast
nnoremap <leader>a :Ack<Space>

" quick change buffers
map <C-j> :bprev<CR>
map <C-k> :bnext<CR>

" Easy window navigation
map <A-h> <C-w>h
map <A-j> <C-w>j
map <A-k> <C-w>k
map <A-l> <C-w>l

" make a new vertical split and go there
nnoremap <leader>w <C-w>v<C-w>l

" cycle thru preview tags
" inspired by http://www.ashberg.de/vim/vimrc.html
map <C-PageUp> :ptp<cr>
map <C-PageDown> :ptn<cr>
imap <C-PageUp> <esc>:silent! ptp<cr>a
imap <C-PageDown> <esc>:silent! ptn<cr>a

" Don't use Ex mode, use Q for formatting
map Q gq

" Insert a blank line below the current line in normal mode.
" Handy because it won't continue code comments.
nmap <space> :put =''<cr>

" IDE-ish plugins
nmap <F1>  :TrinityToggleNERDTree<cr>
"nmap <F2>  :TrinityToggleTagList<cr>
nmap <F2>  :TagbarToggle<cr>
nmap <F3>  :TrinityToggleSourceExplorer<cr>

" filter through xml tidy (must be available on path)
" select xml text in visual mode to use
vmap ,x :!tidy -q -i --indent-spaces 4 -xml<CR>

" dons' haskell typeOf script
map ty yy:.!typeOf -fbang-patterns -ignore-dot-ghci %

" work around a typo i make constantly (:W for :w)
command W w


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" visual settings

" may consider:
" set t_Co=256
" colorscheme gardener
" gardener is pretty but the hlsearch color needs to be red imho
" but beware of how it would interact with cygwin or other crap terminals
colorscheme koehler

" this looks good on my x11 on hugin at least.
"set guifont=Monospace\ Bold\ 11
set guifont=DejaVu\ Sans\ Mono\ 13


" highlight the word under cursor
"highlight flicker cterm=bold ctermfg=white
"au CursorMoved <buffer> exe 'match flicker /\V\<'.escape(expand('<cword>'), '/').'\>/'

" highlight chars that go over the 80-column limit
" inspired by http://drupal.org/node/29325#comment-213746
"highlight OverLength ctermbg=red ctermfg=white guibg=red guifg=white
"match OverLength '\%81v.*'


" \l to toggle highlighting long lines
nnoremap <silent> <Leader>o
\ :if exists('w:long_line_match') <Bar>
\   silent! call matchdelete(w:long_line_match) <Bar>
\   unlet w:long_line_match <Bar>
\ elseif &textwidth > 0 <Bar>
\   let w:long_line_match = matchadd('ErrorMsg', '\%>'.&tw.'v.\+', -1) <Bar>
\ else <Bar>
\   let w:long_line_match = matchadd('ErrorMsg', '\%>80v.\+', -1) <Bar>
\ endif<CR>


